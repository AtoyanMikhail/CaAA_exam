# Алгоритмы построения МОД

## Алгоритм Краскала

## Описание алгоритма

Алгоритм Краскала - это жадный алгоритм для построения минимального остовного дерева (МОД) в связном взвешенном графе. Алгоритм работает следующим образом:

1. Сортируем все рёбра графа по весу в порядке возрастания
2. Инициализируем пустое множество рёбер МОД
3. Последовательно рассматриваем рёбра в порядке возрастания веса:
   - Если добавление ребра не создаёт цикл, добавляем его в МОД
   - Иначе пропускаем ребро
4. Повторяем шаг 3, пока не рассмотрим все рёбра

## Доказательство корректности

### Лемма о безопасном ребре

**Определение**: Ребро называется безопасным, если его добавление к текущему частичному решению не нарушает свойство ацикличности и приводит к оптимальному решению.

**Теорема**: Пусть G = (V, E) - связный взвешенный граф, и пусть A - подмножество рёбер некоторого МОД. Если (u, v) - лёгкое ребро, пересекающее разрез (S, V-S), то ребро (u, v) безопасно для A.

### Доказательство корректности алгоритма Краскала

1. **Инвариант**: На каждом шаге алгоритма множество A является подмножеством некоторого МОД.

2. **База индукции**: В начале A = ∅, что является подмножеством любого МОД.

3. **Шаг индукции**: Предположим, что A является подмножеством некоторого МОД T. Рассмотрим ребро (u, v), которое алгоритм добавляет на текущем шаге.

   - Если (u, v) ∈ T, то A ∪ {(u, v)} ⊆ T
   - Если (u, v) ∉ T, то T ∪ {(u, v)} содержит цикл C
   - В цикле C должно быть ребро (x, y) ∉ A
   - Поскольку алгоритм выбирает рёбра в порядке возрастания веса, w(u, v) ≤ w(x, y)
   - Заменив (x, y) на (u, v) в T, получим дерево T' с не большим весом
   - Следовательно, A ∪ {(u, v)} ⊆ T'

4. **Завершение**: Когда алгоритм завершает работу, A является остовным деревом, так как:
   - A не содержит циклов (по построению)
   - A связно (иначе можно было бы добавить ещё одно ребро)
   - A содержит все вершины графа

## Сложность алгоритма

- Сортировка рёбер: O(E log E)
- Операции с системой непересекающихся множеств: O(E α(V)), где α - обратная функция Аккермана
- Общая сложность: O(E log E)

## Пример работы алгоритма

Рассмотрим граф с 6 вершинами и 9 рёбрами:

```
     4
0 --------- 1
| \       / |
|  \     /  |
3    \  /   2
|     2     |
|    / \    |
|   /   \   |
|  /     \  |
4 /       \ 4
|/         \|
3 --------- 4
     7
```

Алгоритм выберет рёбра в следующем порядке:
1. (1,2) с весом 1
2. (1,3) с весом 2
3. (3,5) с весом 2
4. (0,2) с весом 3
5. (2,4) с весом 5

Итоговый вес МОД: 13

## Алгоритм Прима

### Описание алгоритма

Алгоритм Прима - это жадный алгоритм для построения минимального остовного дерева (МОД) в связном взвешенном графе. Алгоритм работает следующим образом:

1. Выбираем произвольную начальную вершину
2. Инициализируем пустое множество рёбер МОД
3. Пока не посетим все вершины:
   - Находим ребро минимального веса, соединяющее посещённую вершину с непосещённой
   - Добавляем это ребро в МОД
   - Отмечаем новую вершину как посещённую
4. Повторяем шаг 3, пока не посетим все вершины

### Доказательство корректности

1. **Инвариант**: На каждом шаге алгоритма множество посещённых вершин и рёбер МОД образует дерево.

2. **База индукции**: В начале у нас есть только одна вершина, что является деревом.

3. **Шаг индукции**: Предположим, что на текущем шаге у нас есть дерево T. Рассмотрим ребро (u, v), которое алгоритм добавляет на текущем шаге.

   - u ∈ T, v ∉ T
   - (u, v) - ребро минимального веса, соединяющее T с остальным графом
   - Добавление (u, v) к T не создаёт цикл, так как v ∉ T
   - T ∪ {(u, v)} является деревом

4. **Завершение**: Когда алгоритм завершает работу, все вершины посещены, и построенное дерево является остовным.

### Сравнение с алгоритмом Краскала

1. **Сложность**:
   - Алгоритм Прима: O(E log V) с использованием бинарной кучи
   - Алгоритм Краскала: O(E log E)

2. **Особенности**:
   - Прим работает быстрее на плотных графах (E ≈ V²)
   - Краскал работает быстрее на разреженных графах (E ≈ V)
   - Прим требует хранения всего графа в памяти
   - Краскал может работать с рёбрами, поступающими потоком

3. **Применение**:
   - Прим удобен, когда граф представлен матрицей смежности
   - Краскал удобен, когда граф представлен списком рёбер

### Пример работы алгоритма

Рассмотрим тот же граф с 6 вершинами и 9 рёбрами:

```
     4
0 --------- 1
| \       / |
|  \     /  |
3    \  /   2
|     2     |
|    / \    |
|   /   \   |
|  /     \  |
4 /       \ 4
|/         \|
3 --------- 4
     7
```

Алгоритм Прима начнёт с вершины 0 и выберет рёбра в следующем порядке:
1. (0,2) с весом 3
2. (2,1) с весом 1
3. (1,3) с весом 2
4. (3,5) с весом 2
5. (2,4) с весом 5

Итоговый вес МОД: 13 (тот же результат, что и у алгоритма Краскала) 