# Редакционное расстояние

## Введение

Редакционное расстояние (расстояние Левенштейна) - это минимальное количество операций вставки, удаления и замены символов, необходимых для преобразования одной строки в другую.

### Формальное определение

Для строк s и t редакционное расстояние d(s,t) определяется как минимальное количество элементарных операций, необходимых для преобразования s в t, где элементарными операциями являются:
- Вставка символа
- Удаление символа
- Замена символа

### Свойства редакционного расстояния

1. Симметричность: d(s,t) = d(t,s)
2. Неотрицательность: d(s,t) ≥ 0
3. Тождество: d(s,s) = 0
4. Неравенство треугольника: d(s,t) ≤ d(s,u) + d(u,t)

## Динамическое программирование

### Теорема о рекуррентном соотношении

**Теорема**: Редакционное расстояние d(s,t) удовлетворяет следующему рекуррентному соотношению:

d(s[1..i], t[1..j]) = min {
    d(s[1..i-1], t[1..j]) + 1,     // удаление
    d(s[1..i], t[1..j-1]) + 1,     // вставка
    d(s[1..i-1], t[1..j-1]) + cost // замена
}

где cost = 0, если s[i] = t[j], и cost = 1 иначе.

**Доказательство**:
1. База: d(ε,ε) = 0, d(s,ε) = |s|, d(ε,t) = |t|
2. Шаг: Рассмотрим последнюю операцию:
   - Если это удаление: d(s[1..i], t[1..j]) = d(s[1..i-1], t[1..j]) + 1
   - Если это вставка: d(s[1..i], t[1..j]) = d(s[1..i], t[1..j-1]) + 1
   - Если это замена: d(s[1..i], t[1..j]) = d(s[1..i-1], t[1..j-1]) + cost

### Алгоритм вычисления

```python
def levenshtein_distance(s, t):
    m, n = len(s), len(t)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # База
    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j
        
    # Заполнение таблицы
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s[i-1] == t[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = min(
                    dp[i-1][j] + 1,    # удаление
                    dp[i][j-1] + 1,    # вставка
                    dp[i-1][j-1] + 1   # замена
                )
    
    return dp[m][n]
```

### Восстановление последовательности операций

**Теорема**: Последовательность операций, приводящая к минимальному редакционному расстоянию, может быть восстановлена из таблицы динамического программирования.

**Доказательство**:
1. Каждая ячейка dp[i][j] содержит минимальное расстояние для подстрок s[1..i] и t[1..j]
2. Значение dp[i][j] получено из одной из трёх предыдущих ячеек
3. Выбор предыдущей ячейки определяет операцию

```python
def restore_operations(s, t, dp):
    operations = []
    i, j = len(s), len(t)
    
    while i > 0 or j > 0:
        if i > 0 and j > 0 and s[i-1] == t[j-1]:
            i -= 1
            j -= 1
        elif j > 0 and (i == 0 or dp[i][j] == dp[i][j-1] + 1):
            operations.append(('insert', j-1, t[j-1]))
            j -= 1
        elif i > 0 and (j == 0 or dp[i][j] == dp[i-1][j] + 1):
            operations.append(('delete', i-1, s[i-1]))
            i -= 1
        else:
            operations.append(('replace', i-1, s[i-1], t[j-1]))
            i -= 1
            j -= 1
            
    return list(reversed(operations))
```

## Сведение к путям в графе

### Теорема о сведении

**Теорема**: Задача вычисления редакционного расстояния может быть сведена к задаче поиска кратчайшего пути в ориентированном ациклическом графе.

**Доказательство**:
1. Построим граф G = (V,E):
   - V = {(i,j) | 0 ≤ i ≤ m, 0 ≤ j ≤ n}
   - E = {(i,j) → (i+1,j), (i,j) → (i,j+1), (i,j) → (i+1,j+1)}
2. Веса рёбер:
   - (i,j) → (i+1,j): вес 1 (удаление)
   - (i,j) → (i,j+1): вес 1 (вставка)
   - (i,j) → (i+1,j+1): вес 0 или 1 (замена)
3. Кратчайший путь от (0,0) до (m,n) даёт минимальное редакционное расстояние

### Реализация через граф

```python
def edit_distance_graph(s, t):
    m, n = len(s), len(t)
    
    # Создаём граф
    graph = {}
    for i in range(m + 1):
        for j in range(n + 1):
            graph[(i,j)] = []
            
            # Удаление
            if i < m:
                graph[(i,j)].append(((i+1,j), 1))
                
            # Вставка
            if j < n:
                graph[(i,j)].append(((i,j+1), 1))
                
            # Замена
            if i < m and j < n:
                cost = 0 if s[i] == t[j] else 1
                graph[(i,j)].append(((i+1,j+1), cost))
    
    # Поиск кратчайшего пути
    return dijkstra(graph, (0,0), (m,n))
```

## Оптимизации

### Теорема о пространственной оптимизации

**Теорема**: Для вычисления редакционного расстояния достаточно хранить только две строки таблицы динамического программирования.

**Доказательство**:
1. Для вычисления dp[i][j] нужны только значения:
   - dp[i-1][j]
   - dp[i][j-1]
   - dp[i-1][j-1]
2. Эти значения находятся в предыдущей строке и текущей позиции
3. Достаточно хранить текущую и предыдущую строки

```python
def levenshtein_distance_optimized(s, t):
    m, n = len(s), len(t)
    if m < n:
        return levenshtein_distance_optimized(t, s)
        
    # Храним только две строки
    prev = list(range(n + 1))
    curr = [0] * (n + 1)
    
    for i in range(1, m + 1):
        curr[0] = i
        for j in range(1, n + 1):
            if s[i-1] == t[j-1]:
                curr[j] = prev[j-1]
            else:
                curr[j] = min(
                    prev[j] + 1,     # удаление
                    curr[j-1] + 1,   # вставка
                    prev[j-1] + 1    # замена
                )
        prev, curr = curr, prev
        
    return prev[n]
```

## Применения

### Проверка правописания

**Теорема**: Задача исправления опечаток может быть сведена к задаче поиска слова с минимальным редакционным расстоянием.

**Доказательство**:
1. Словарь представляется как множество строк
2. Для слова с опечаткой находим ближайшее слово из словаря
3. Редакционное расстояние определяет "близость" слов

### Анализ ДНК

**Теорема**: Задача сравнения последовательностей ДНК может быть сведена к задаче редакционного расстояния с весами операций.

**Доказательство**:
1. Последовательности ДНК представляются как строки
2. Операции имеют разные веса:
   - Замена: зависит от типов нуклеотидов
   - Вставка/удаление: фиксированный вес
3. Минимальное расстояние определяет схожесть последовательностей

## Сложность алгоритмов

### Базовый алгоритм
- Время: O(mn)
- Память: O(mn)

### Оптимизированный алгоритм
- Время: O(mn)
- Память: O(min(m,n))

### Алгоритм через граф
- Время: O(mn log(mn))
- Память: O(mn)

где:
- m - длина первой строки
- n - длина второй строки 