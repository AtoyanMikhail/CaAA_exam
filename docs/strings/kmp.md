# Алгоритм Кнута-Морриса-Пратта

## Введение

Алгоритм Кнута-Морриса-Пратта (КМП) - это алгоритм поиска подстроки в строке, использующий информацию о предыдущих совпадениях для оптимизации поиска.

### Основные определения

1. Строка: последовательность символов s = s₁s₂...sₙ
2. Подстрока: последовательность символов p = p₁p₂...pₘ
3. Префикс строки s: подстрока s[1..i] для некоторого i
4. Суффикс строки s: подстрока s[i..n] для некоторого i
5. Префикс-функция π[i]: длина наибольшего собственного префикса строки s[1..i], который является суффиксом этой же строки

## Задача точного поиска образца

### Формальная постановка

Даны:
- Строка s = s₁s₂...sₙ
- Образец p = p₁p₂...pₘ

Найти:
- Все позиции i, где p является подстрокой s, то есть s[i..i+m-1] = p

### Наивный алгоритм

**Теорема**: Наивный алгоритм имеет сложность O(nm) в худшем случае.

**Доказательство**:
1. Для каждой позиции i в строке s проверяем совпадение с образцом p
2. В худшем случае (например, s = "aaa...a", p = "aa...ab") для каждой позиции нужно проверить все символы образца
3. Итого: O(nm) операций сравнения

```python
def naive_search(s, p):
    n, m = len(s), len(p)
    result = []
    
    for i in range(n - m + 1):
        if s[i:i+m] == p:
            result.append(i)
            
    return result
```

## Алгоритм КМП

### Идея алгоритма

**Теорема**: Если при поиске образца p в строке s произошло несовпадение в позиции j образца, то можно сдвинуть образец на π[j] позиций вправо.

**Доказательство**:
1. Пусть s[i..i+j-1] = p[1..j-1], но s[i+j] ≠ p[j]
2. По определению префикс-функции, p[1..π[j]] = p[j-π[j]+1..j]
3. Следовательно, s[i+j-π[j]..i+j-1] = p[1..π[j]]
4. Можно сдвинуть образец на j-π[j] позиций

### Реализация алгоритма

```python
def kmp_search(s, p):
    n, m = len(s), len(p)
    pi = compute_prefix_function(p)
    result = []
    j = 0  # текущая позиция в образце
    
    for i in range(n):
        while j > 0 and s[i] != p[j]:
            j = pi[j-1]
            
        if s[i] == p[j]:
            j += 1
            
        if j == m:
            result.append(i - m + 1)
            j = pi[j-1]
            
    return result
```

## Префикс-функция

### Наивное построение

**Теорема**: Наивное построение префикс-функции имеет сложность O(m³).

**Доказательство**:
1. Для каждой позиции i проверяем все возможные длины префиксов
2. Для каждой длины проверяем совпадение префикса и суффикса
3. Итого: O(m) * O(m) * O(m) = O(m³) операций

```python
def naive_prefix_function(p):
    m = len(p)
    pi = [0] * m
    
    for i in range(1, m):
        for j in range(i, 0, -1):
            if p[:j] == p[i-j+1:i+1]:
                pi[i] = j
                break
                
    return pi
```

### Линейное построение

**Теорема**: Префикс-функцию можно построить за O(m) времени.

**Доказательство**:
1. Для каждой позиции i значение π[i] ≤ π[i-1] + 1
2. При несовпадении используем уже вычисленные значения π
3. Каждое уменьшение j происходит не более i раз
4. Итого: O(m) операций

```python
def compute_prefix_function(p):
    m = len(p)
    pi = [0] * m
    
    for i in range(1, m):
        j = pi[i-1]
        while j > 0 and p[i] != p[j]:
            j = pi[j-1]
            
        if p[i] == p[j]:
            j += 1
            
        pi[i] = j
        
    return pi
```

### Оптимизация памяти

**Теорема**: Алгоритм КМП можно реализовать с использованием O(1) дополнительной памяти.

**Доказательство**:
1. Префикс-функцию можно вычислять на лету
2. Для поиска достаточно хранить текущую позицию в образце
3. Итого: O(1) дополнительной памяти

```python
def kmp_search_optimized(s, p):
    n, m = len(s), len(p)
    result = []
    j = 0  # текущая позиция в образце
    
    # Вычисляем префикс-функцию на лету
    pi = [0] * m
    for i in range(1, m):
        j = pi[i-1]
        while j > 0 and p[i] != p[j]:
            j = pi[j-1]
        if p[i] == p[j]:
            j += 1
        pi[i] = j
        
    # Поиск образца
    j = 0
    for i in range(n):
        while j > 0 and s[i] != p[j]:
            j = pi[j-1]
            
        if s[i] == p[j]:
            j += 1
            
        if j == m:
            result.append(i - m + 1)
            j = pi[j-1]
            
    return result
```

## Сложность алгоритмов

### Наивный алгоритм
- Время: O(nm)
- Память: O(1)

### Алгоритм КМП
- Время: O(n + m)
- Память: O(m)

### Оптимизированный КМП
- Время: O(n + m)
- Память: O(1)

где:
- n - длина строки
- m - длина образца

## Применения

### Поиск подстроки
- Точный поиск образца в тексте
- Поиск всех вхождений образца
- Поиск наибольшей общей подстроки

### Сжатие данных
- Алгоритм LZ77 использует идеи КМП
- Поиск повторяющихся подстрок
- Оптимизация сжатия

### Биоинформатика
- Поиск последовательностей в ДНК
- Анализ белковых структур
- Сравнение геномов 