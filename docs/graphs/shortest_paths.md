# Алгоритмы поиска кратчайших путей

## Поиск в ширину (BFS)

### Описание
Поиск в ширину - это алгоритм обхода графа, который находит кратчайший путь между двумя вершинами в невзвешенном графе.

### Псевдокод
```
function BFS(graph, start, end):
    queue = [start]
    visited = {start}
    parent = {start: None}
    
    while queue:
        current = queue.pop(0)
        if current == end:
            return reconstruct_path(parent, start, end)
            
        for neighbor in graph[current]:
            if neighbor not in visited:
                visited.add(neighbor)
                parent[neighbor] = current
                queue.append(neighbor)
    
    return None
```

### Сложность
- Время: O(|V| + |E|)
- Память: O(|V|)

## Алгоритм Дейкстры

### Описание
Алгоритм Дейкстры находит кратчайшие пути от начальной вершины до всех остальных вершин во взвешенном графе с неотрицательными весами рёбер.

### Псевдокод
```
function Dijkstra(graph, start):
    dist = {v: ∞ for v in graph}
    dist[start] = 0
    pq = PriorityQueue([(0, start)])
    parent = {start: None}
    
    while pq:
        d, u = pq.pop()
        if d > dist[u]:
            continue
            
        for v, w in graph[u]:
            if dist[v] > dist[u] + w:
                dist[v] = dist[u] + w
                parent[v] = u
                pq.push((dist[v], v))
    
    return dist, parent
```

### Сложность
- Время: O((|V| + |E|)log|V|) с бинарной кучей
- Память: O(|V|)

## Алгоритм A*

### Описание
A* - это алгоритм поиска пути, который использует эвристическую функцию для оценки стоимости пути до цели. Он является обобщением алгоритма Дейкстры.

### Псевдокод
```
function A*(graph, start, end, h):
    open_set = {start}
    closed_set = set()
    g_score = {start: 0}
    f_score = {start: h(start)}
    parent = {start: None}
    
    while open_set:
        current = min(open_set, key=lambda x: f_score[x])
        if current == end:
            return reconstruct_path(parent, start, end)
            
        open_set.remove(current)
        closed_set.add(current)
        
        for neighbor in graph[current]:
            if neighbor in closed_set:
                continue
                
            tentative_g = g_score[current] + graph[current][neighbor]
            
            if neighbor not in open_set:
                open_set.add(neighbor)
            elif tentative_g >= g_score[neighbor]:
                continue
                
            parent[neighbor] = current
            g_score[neighbor] = tentative_g
            f_score[neighbor] = g_score[neighbor] + h(neighbor)
    
    return None
```

### Эвристические функции

#### 1. Манхэттенское расстояние
```
h(x, y) = |x1 - x2| + |y1 - y2|
```
- Допустимая для сетки с движением по горизонтали и вертикали
- Не переоценивает реальное расстояние

#### 2. Евклидово расстояние
```
h(x, y) = √((x1 - x2)² + (y1 - y2)²)
```
- Допустимая для непрерывного пространства
- Не переоценивает реальное расстояние

#### 3. Диагональное расстояние
```
h(x, y) = max(|x1 - x2|, |y1 - y2|)
```
- Допустимая для сетки с диагональным движением
- Учитывает диагональные перемещения

### Доказательство оптимальности

#### Лемма 1: Допустимость эвристики
Если h(n) ≤ h*(n) для всех вершин n, где h*(n) - реальная стоимость пути от n до цели, то A* находит оптимальный путь.

**Доказательство**:
1. Пусть P - оптимальный путь
2. Для любой вершины n на P: f(n) = g(n) + h(n) ≤ g(n) + h*(n) = cost(P)
3. Следовательно, A* никогда не выберет путь с большей стоимостью

#### Лемма 2: Монотонность
Если h(n) ≤ h*(n) и h(n) ≥ h(m) - cost(n,m) для всех рёбер (n,m), то A* находит оптимальный путь без пересмотра вершин.

**Доказательство**:
1. При добавлении вершины n в closed_set, f(n) = g(n) + h(n)
2. Для любой вершины m, достижимой из n: f(m) ≥ f(n)
3. Следовательно, n никогда не будет пересмотрена

### Ограничения A*

1. **Требования к эвристике**:
   - Должна быть допустимой (не переоценивать)
   - Желательно монотонной
   - Должна быть эффективно вычислимой

2. **Память**:
   - Хранит все посещённые вершины
   - Может быть проблемой для больших графов

3. **Вычислительная сложность**:
   - В худшем случае O(|V|²)
   - Зависит от качества эвристики

### Примеры применения

1. **Навигация**:
   - Поиск маршрута в GPS
   - Планирование движения роботов
   - Игровая навигация

2. **Игры**:
   - Поиск пути для NPC
   - Генерация лабиринтов
   - ИИ для стратегических игр

3. **Сетевые технологии**:
   - Маршрутизация пакетов
   - Оптимизация сетевых соединений
   - Балансировка нагрузки

### Сравнение алгоритмов

| Алгоритм | Преимущества | Недостатки |
|----------|--------------|------------|
| BFS | Простой, гарантирует кратчайший путь | Только для невзвешенных графов |
| Дейкстра | Работает с весами, оптимальный | Только для неотрицательных весов |
| A* | Эффективен с хорошей эвристикой | Требует допустимую эвристику | 