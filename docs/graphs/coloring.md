# Раскраска графа в 3 цвета

## Описание задачи

Задача раскраски графа в 3 цвета заключается в присвоении каждой вершине графа одного из трех цветов так, чтобы никакие две смежные вершины не были окрашены в один цвет. Формально:

- Дано: граф G = (V, E)
- Требуется: найти функцию c: V → {0, 1, 2}, такую что для любых (u, v) ∈ E выполняется c(u) ≠ c(v)

## Алгоритмы решения

### 1. Алгоритм полного перебора

**Идея алгоритма**:
- Перебираем все возможные раскраски вершин
- Проверяем каждую раскраску на допустимость
- Возвращаем первую найденную допустимую раскраску

**Сложность**: O(3^n), где n - количество вершин

**Псевдокод**:
```
function try_coloring(vertex, colors):
    if vertex == n:
        return True
        
    for color in [0, 1, 2]:
        colors[vertex] = color
        if is_valid_coloring(colors[:vertex+1]):
            if try_coloring(vertex + 1, colors):
                return True
        colors[vertex] = -1
        
    return False
```

### 2. Перебор с учетом выбора только из 2 цветов

**Идея алгоритма**:
- Для каждой вершины рассматриваем только те цвета, которые не используются в смежных вершинах
- Это уменьшает количество перебираемых вариантов

**Сложность**: O(2^n) в худшем случае

**Псевдокод**:
```
function get_available_colors(vertex, colors):
    used_colors = {colors[v] for v in adj[vertex] if colors[v] != -1}
    return {0, 1, 2} - used_colors

function try_coloring(vertex, colors):
    if vertex == n:
        return True
        
    available_colors = get_available_colors(vertex, colors)
    for color in available_colors:
        colors[vertex] = color
        if try_coloring(vertex + 1, colors):
            return True
        colors[vertex] = -1
        
    return False
```

### 3. Перебор подмножеств размера ≤ n/3

**Идея алгоритма**:
- Перебираем все возможные подмножества вершин размера ≤ n/3
- Раскрашиваем каждое подмножество в цвет 0
- Пробуем раскрасить оставшиеся вершины в цвета 1 и 2

**Сложность**: O(2^(n/3) * 2^(2n/3)) = O(2^n)

**Псевдокод**:
```
for size in range(n/3 + 1):
    for subset in combinations(vertices, size):
        colors = [-1] * n
        for v in subset:
            colors[v] = 0
            
        if try_coloring_remaining(colors, 1):
            return colors
```

### 4. Вероятностный алгоритм

**Идея алгоритма**:
- Случайным образом присваиваем цвета вершинам
- Проверяем допустимость раскраски
- Повторяем заданное количество раз

**Сложность**: O(k * n), где k - количество попыток

**Псевдокод**:
```
for attempt in range(max_attempts):
    colors = random_colors(n)
    if is_valid_coloring(colors):
        return colors
```

### 5. Сведение к задаче выполнимости (SAT)

**Идея алгоритма**:
- Каждой вершине и цвету сопоставляем булеву переменную
- Формулируем условия раскраски в виде CNF:
  1. Каждая вершина должна быть окрашена хотя бы в один цвет
  2. Каждая вершина не может быть окрашена в два цвета одновременно
  3. Смежные вершины не могут быть окрашены в один цвет

**Сложность**: O(n + m), где m - количество ребер

**Псевдокод**:
```
clauses = []
# Каждая вершина должна быть окрашена хотя бы в один цвет
for v in vertices:
    clauses.append([3*v + 1, 3*v + 2, 3*v + 3])

# Каждая вершина не может быть окрашена в два цвета одновременно
for v in vertices:
    for c1, c2 in combinations([1, 2, 3], 2):
        clauses.append([-(3*v + c1), -(3*v + c2)])

# Смежные вершины не могут быть окрашены в один цвет
for (u, v) in edges:
    for c in [1, 2, 3]:
        clauses.append([-(3*u + c), -(3*v + c)])
```

## Применение на практике

1. **Расписание занятий**:
   - Вершины - занятия
   - Ребра - конфликты по времени/аудитории
   - Цвета - временные слоты

2. **Распределение ресурсов**:
   - Вершины - процессы
   - Ребра - конфликты по ресурсам
   - Цвета - доступные ресурсы

3. **Компиляция программ**:
   - Вершины - переменные
   - Ребра - конфликты по регистрам
   - Цвета - регистры процессора

4. **Сотовые сети**:
   - Вершины - базовые станции
   - Ребра - зоны покрытия
   - Цвета - частотные каналы

5. **Расписание экзаменов**:
   - Вершины - экзамены
   - Ребра - конфликты по студентам
   - Цвета - временные слоты

## Преимущества и недостатки алгоритмов

### Полный перебор
- **Преимущества**: находит оптимальное решение
- **Недостатки**: экспоненциальная сложность

### Перебор с двумя цветами
- **Преимущества**: быстрее полного перебора
- **Недостатки**: все еще экспоненциальная сложность

### Перебор подмножеств
- **Преимущества**: может быть эффективнее для некоторых графов
- **Недостатки**: сложная реализация, экспоненциальная сложность

### Вероятностный алгоритм
- **Преимущества**: быстрый, простой
- **Недостатки**: не гарантирует нахождение решения

### Сведение к SAT
- **Преимущества**: можно использовать эффективные SAT-солверы
- **Недостатки**: большое количество переменных и дизъюнктов 