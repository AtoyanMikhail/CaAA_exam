# Алгоритмы минимального разреза

## Введение

Минимальный разрез графа - это разбиение множества вершин на два подмножества, такое что сумма весов рёбер между этими подмножествами минимальна. Эта задача имеет множество приложений в сетевом анализе, кластеризации и оптимизации.

## Теорема о минимальном разрезе

### Теорема
В любом графе существует минимальный разрез, который разделяет граф на две компоненты связности.

### Доказательство
1. Минимальный разрез всегда существует, так как множество всех возможных разрезов конечно
2. Если разрез не разделяет граф на компоненты связности, то его можно улучшить

## Алгоритм Каргера

### Теорема
Алгоритм Каргера находит минимальный разрез с вероятностью не менее 2/(n(n-1)).

### Доказательство
1. Вероятность того, что конкретное ребро минимального разреза не будет выбрано для схлопывания, равна (n-2)/n
2. После k схлопываний эта вероятность становится (n-k-1)/(n-k)
3. Перемножая вероятности для всех шагов, получаем требуемую оценку

### Реализация

```python
def karger_min_cut(graph: Graph) -> Tuple[int, List[Tuple[int, int]]]:
    """
    Алгоритм Каргера для нахождения минимального разреза.
    
    Args:
        graph: Граф
        
    Returns:
        (вес разреза, список ребер в разрезе)
    """
    n = graph.vertices
    ds = DisjointSet(n)
    edges = graph.edges.copy()
    random.shuffle(edges)
    
    # Объединяем вершины, пока не останется две
    vertices = n
    for u, v, w in edges:
        if vertices <= 2:
            break
            
        if ds.find(u) != ds.find(v):
            ds.union(u, v)
            vertices -= 1
    
    # Находим ребра разреза
    cut_edges = []
    cut_weight = 0
    
    for u, v, w in edges:
        if ds.find(u) != ds.find(v):
            cut_edges.append((u, v))
            cut_weight += w
    
    return cut_weight, cut_edges
```

## Алгоритм Каргера-Штейна

### Теорема
Алгоритм Каргера-Штейна находит минимальный разрез с вероятностью не менее 1/log n.

### Доказательство
1. Использует рекурсивное схлопывание графа
2. На каждом уровне рекурсии вероятность успеха увеличивается
3. Итоговая вероятность получается из произведения вероятностей на всех уровнях

### Реализация

```python
def karger_stein_min_cut(graph: Graph) -> Tuple[int, List[Tuple[int, int]]]:
    """
    Оптимизированный алгоритм Каргера-Штейна для нахождения минимального разреза.
    
    Args:
        graph: Граф
        
    Returns:
        (вес разреза, список ребер в разрезе)
    """
    def contract(graph: Graph, t: int) -> Graph:
        """Схлопывает граф до t вершин"""
        n = graph.vertices
        ds = DisjointSet(n)
        edges = graph.edges.copy()
        random.shuffle(edges)
        
        vertices = n
        for u, v, w in edges:
            if vertices <= t:
                break
                
            if ds.find(u) != ds.find(v):
                ds.union(u, v)
                vertices -= 1
        
        # Создаем новый граф
        new_graph = Graph(t)
        new_edges = defaultdict(int)
        
        for u, v, w in edges:
            pu, pv = ds.find(u), ds.find(v)
            if pu != pv:
                new_edges[(pu, pv)] += w
        
        for (u, v), w in new_edges.items():
            new_graph.add_edge(u, v, w)
        
        return new_graph
    
    def recursive_min_cut(graph: Graph) -> Tuple[int, List[Tuple[int, int]]]:
        """Рекурсивная часть алгоритма"""
        n = graph.vertices
        if n <= 6:
            return karger_min_cut(graph)
        
        t = int(n / (2 ** 0.5) + 1)
        g1 = contract(graph, t)
        g2 = contract(graph, t)
        
        cut1 = recursive_min_cut(g1)
        cut2 = recursive_min_cut(g2)
        
        return min(cut1, cut2, key=lambda x: x[0])
    
    return recursive_min_cut(graph)
```

## Многократный запуск

### Теорема
При запуске алгоритма Каргера-Штейна O(log²n) раз, вероятность нахождения минимального разреза стремится к 1.

### Доказательство
1. Вероятность успеха одного запуска ≥ 1/log n
2. Вероятность неудачи всех запусков ≤ (1 - 1/log n)^(log²n)
3. При n → ∞ эта вероятность стремится к 0

### Реализация

```python
def find_min_cut(graph: Graph, num_trials: int = 100) -> Tuple[int, List[Tuple[int, int]]]:
    """
    Находит минимальный разрез, запуская алгоритм Каргера-Штейна несколько раз.
    
    Args:
        graph: Граф
        num_trials: Количество попыток
        
    Returns:
        (вес минимального разреза, список ребер в разрезе)
    """
    best_cut = float('inf'), []
    
    for _ in range(num_trials):
        cut = karger_stein_min_cut(graph)
        if cut[0] < best_cut[0]:
            best_cut = cut
    
    return best_cut
```

## Сложность алгоритмов

### Алгоритм Каргера
- Время: O(n²)
- Память: O(n + m)

### Алгоритм Каргера-Штейна
- Время: O(n² log n)
- Память: O(n + m)

### Многократный запуск
- Время: O(n² log³n)
- Память: O(n + m)

## Применения

### Сетевой анализ
- Нахождение уязвимых мест в сети
- Анализ связности
- Обнаружение сообществ

### Кластеризация
- Разделение данных на кластеры
- Сегментация изображений
- Анализ социальных сетей

### Оптимизация
- Балансировка нагрузки
- Распределение ресурсов
- Планирование маршрутов 