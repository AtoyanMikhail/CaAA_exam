# Алгоритмы поиска максимального потока

## Введение

Представьте, что у вас есть сеть труб, по которым нужно перекачать максимальное количество воды из источника в сток. Каждая труба имеет ограничение на пропускную способность. Как найти максимальный поток, который можно пропустить через эту сеть? Эту задачу решают алгоритмы поиска максимального потока.

## Алгоритм Форда-Фалкерсона

### Как это работает?

1. Начинаем с пустой сети (нулевой поток)
2. Ищем путь от источника к стоку, по которому можно пропустить дополнительный поток
3. Увеличиваем поток вдоль этого пути
4. Повторяем, пока такие пути существуют

### Пример

```
Исходная сеть:
    A
   / \
  3   2
 /     \
S        T
 \     /
  2   3
   \ /
    B

Шаг 1: Находим путь S->A->T
    A
   / \
  2   0
 /     \
S        T
 \     /
  2   3
   \ /
    B

Шаг 2: Находим путь S->B->T
    A
   / \
  2   0
 /     \
S        T
 \     /
  0   1
   \ /
    B
```

### Остаточная сеть

Остаточная сеть - это ключевая идея алгоритма. Она позволяет не только пропускать поток вперёд, но и "отменять" уже пропущенный поток.

Для каждого ребра (u,v) с пропускной способностью c и текущим потоком f:
- Прямое ребро: остаточная пропускная способность = c - f
- Обратное ребро: остаточная пропускная способность = f

### Сложность
- Время: O(E * |f*|), где E - число рёбер, |f*| - величина максимального потока
- Память: O(V + E)

## Алгоритм проталкивания предпотока (Гольдберга)

### Интуитивное понимание

Представьте, что вершины - это резервуары с водой, а рёбра - трубы. Вода может течь только "вниз" (из резервуара с большей высотой в резервуар с меньшей). Если вода не может течь, мы поднимаем резервуар.

### Основные понятия

1. Предпоток:
   - Вода может временно накапливаться в резервуарах
   - Источник может производить неограниченное количество воды
   - Сток может поглощать неограниченное количество воды

2. Высота вершины:
   - Источник находится на максимальной высоте
   - Сток находится на нулевой высоте
   - Вода течёт только вниз

3. Активная вершина:
   - Резервуар, в котором есть избыток воды
   - Нужно либо протолкнуть воду дальше, либо поднять резервуар

### Пример работы

```
Начальное состояние:
    A(0)
   / \
  3   2
 /     \
S(5)    T(0)
 \     /
  2   3
   \ /
    B(0)

Шаг 1: Push(S->A)
    A(2)
   / \
  1   2
 /     \
S(3)    T(0)
 \     /
  2   3
   \ /
    B(0)

Шаг 2: Push(S->B)
    A(2)
   / \
  1   2
 /     \
S(1)    T(0)
 \     /
  0   3
   \ /
    B(2)
```

### Операции алгоритма

1. Push(u,v):
   - Проталкиваем воду из u в v
   - Возможно только если высота u на 1 больше высоты v
   - Количество воды = min(избыток в u, остаточная пропускная способность ребра)

2. Relabel(u):
   - Поднимаем резервуар u
   - Новая высота = минимальная высота соседа + 1
   - Выполняется, когда нельзя протолкнуть воду

### Доказательство корректности

1. Инварианты:
   - Высота источника всегда |V|
   - Высота стока всегда 0
   - Вода течёт только вниз
   - Избыток только в промежуточных вершинах

2. Ограничения:
   - Высота вершины не превышает 2|V| - 1
   - Количество операций relabel не более 2|V|²
   - Количество операций push не более 2|V|E

3. Завершение:
   - Когда нет активных вершин, получаем максимальный поток
   - Все избытки стекают в сток

### Сложность
- Время: O(V²E)
- Память: O(V²)

### Сравнение алгоритмов

Форд-Фалкерсон:
- Плюсы: прост в реализации, понятен
- Минусы: может работать медленно на некоторых графах

Гольдберг:
- Плюсы: гарантированная быстрая работа, не зависит от величины потока
- Минусы: сложнее реализовать, больше констант

## Применение

1. Максимальное паросочетание:
   - Добавляем источник и сток
   - Каждое ребро имеет пропускную способность 1
   - Максимальный поток = максимальное паросочетание

2. Минимальный разрез:
   - Находим максимальный поток
   - Минимальный разрез = множество рёбер, насыщенных потоком

3. Поток с ограничениями:
   - Добавляем фиктивные вершины
   - Используем алгоритм проталкивания предпотока

4. Поток минимальной стоимости:
   - Комбинируем с алгоритмом поиска кратчайшего пути
   - Ищем путь минимальной стоимости в остаточной сети 