# Изоморфизм графов

## Введение

Два графа называются изоморфными, если существует биекция между их вершинами, сохраняющая смежность. Задача изоморфизма графов заключается в проверке, являются ли два графа изоморфными.

### Формальное определение

Графы G₁ = (V₁, E₁) и G₂ = (V₂, E₂) изоморфны, если существует биекция f: V₁ → V₂ такая, что:
- ∀u,v ∈ V₁: (u,v) ∈ E₁ ⇔ (f(u),f(v)) ∈ E₂

### Необходимые условия изоморфизма

1. Одинаковое число вершин: |V₁| = |V₂|
2. Одинаковое число рёбер: |E₁| = |E₂|
3. Одинаковый набор степеней вершин
4. Одинаковое число циклов каждой длины
5. Одинаковое число компонент связности

## Точный изоморфизм

### Теорема о сложности

**Теорема**: Задача проверки изоморфизма графов принадлежит классу NP, но не известно, является ли она NP-полной.

**Доказательство**:
1. Принадлежность к NP:
   - Свидетельство: биекция между вершинами
   - Проверка: O(n²) операций для проверки сохранения смежности
   
2. Неизвестная NP-полнота:
   - Не найдено полиномиальное сведение от известных NP-полных задач
   - Существуют эффективные алгоритмы для специальных классов графов

### Алгоритм полного перебора

Идея алгоритма:
1. Проверка необходимых условий
2. Перебор всех возможных биекций
3. Проверка сохранения смежности

**Теорема**: Алгоритм полного перебора имеет сложность O(n! * n²).

**Доказательство**:
1. Число перестановок: n!
2. Проверка каждой перестановки: O(n²)
3. Итого: O(n! * n²)

```python
class GraphIsomorphism:
    def __init__(self, graph1, graph2):
        self.graph1 = graph1  # Список смежности первого графа
        self.graph2 = graph2  # Список смежности второго графа
        self.n1 = len(graph1)
        self.n2 = len(graph2)
        
    def is_isomorphic(self):
        if self.n1 != self.n2:
            return False
            
        # Проверяем степени вершин
        degrees1 = [len(adj) for adj in self.graph1]
        degrees2 = [len(adj) for adj in self.graph2]
        if sorted(degrees1) != sorted(degrees2):
            return False
            
        # Перебираем все возможные перестановки вершин
        vertices = list(range(self.n1))
        for perm in itertools.permutations(vertices):
            if self._check_permutation(perm):
                return True
        return False
        
    def _check_permutation(self, perm):
        # Проверяем, сохраняет ли перестановка смежность
        for i in range(self.n1):
            for j in self.graph1[i]:
                if perm[j] not in self.graph2[perm[i]]:
                    return False
        return True
```

## Поиск подграфа в графе

### Теорема о сложности

**Теорема**: Задача поиска подграфа является NP-полной.

**Доказательство**:
1. Принадлежность к NP:
   - Свидетельство: отображение вершин подграфа
   - Проверка: O(n²) операций
   
2. NP-полнота:
   - Сведение от задачи клики
   - Клика является частным случаем подграфа

### Алгоритм поиска подграфа

Идея алгоритма:
1. Проверка необходимых условий
2. Перебор всех возможных подмножеств вершин
3. Проверка изоморфизма для каждого подмножества

**Теорема**: Алгоритм имеет сложность O(n! * C(n,m) * n²).

**Доказательство**:
1. Число подмножеств: C(n,m)
2. Для каждого подмножества: n! перестановок
3. Проверка каждой перестановки: O(n²)
4. Итого: O(n! * C(n,m) * n²)

```python
class SubgraphIsomorphism:
    def __init__(self, pattern, graph):
        self.pattern = pattern  # Искомый подграф
        self.graph = graph      # Исходный граф
        self.n1 = len(pattern)
        self.n2 = len(graph)
        
    def find_subgraph(self):
        if self.n1 > self.n2:
            return []
            
        # Проверяем степени вершин
        degrees1 = [len(adj) for adj in self.pattern]
        degrees2 = [len(adj) for adj in self.graph]
        if max(degrees1) > max(degrees2):
            return []
            
        # Перебираем все возможные подмножества вершин
        for subset in itertools.combinations(range(self.n2), self.n1):
            if self._check_subset(subset):
                return list(subset)
        return []
        
    def _check_subset(self, subset):
        # Проверяем, является ли подграф изоморфным
        for perm in itertools.permutations(range(self.n1)):
            if self._check_permutation(perm, subset):
                return True
        return False
        
    def _check_permutation(self, perm, subset):
        # Проверяем, сохраняет ли перестановка смежность
        for i in range(self.n1):
            for j in self.pattern[i]:
                if subset[perm[j]] not in self.graph[subset[perm[i]]]:
                    return False
        return True
```

## Алгоритм Ульмана

### Теорема о корректности

**Теорема**: Алгоритм Ульмана находит все возможные изоморфизмы подграфа.

**Доказательство**:
1. Матрица M содержит все возможные отображения вершин
2. Рекурсивный поиск перебирает все допустимые комбинации
3. Проверка сохранения смежности гарантирует корректность

### Оптимизации алгоритма

1. Предварительная фильтрация:
   - Проверка степеней вершин
   - Проверка числа рёбер
   - Проверка связности

2. Улучшение матрицы M:
   - Использование дополнительных ограничений
   - Применение эвристик для уменьшения размера

**Теорема**: Оптимизированный алгоритм имеет сложность O(n! * n²).

**Доказательство**:
1. Предварительная фильтрация: O(n²)
2. Построение матрицы M: O(n²)
3. Рекурсивный поиск: O(n! * n²)
4. Итого: O(n! * n²)

```python
class UllmannIsomorphism:
    def __init__(self, pattern, graph):
        self.pattern = pattern  # Матрица смежности подграфа
        self.graph = graph      # Матрица смежности графа
        self.n1 = len(pattern)
        self.n2 = len(graph)
        
    def find_isomorphism(self):
        if self.n1 > self.n2:
            return []
            
        # Инициализация матрицы M
        M = [[0 for _ in range(self.n2)] for _ in range(self.n1)]
        for i in range(self.n1):
            for j in range(self.n2):
                if self._can_map(i, j):
                    M[i][j] = 1
                    
        # Поиск изоморфизма
        result = []
        self._ullmann_search(0, M, result)
        return result
        
    def _can_map(self, i, j):
        # Проверяем, можно ли отобразить вершину i в вершину j
        for k in range(self.n1):
            if self.pattern[i][k] == 1:
                has_edge = False
                for l in range(self.n2):
                    if self.graph[j][l] == 1:
                        has_edge = True
                        break
                if not has_edge:
                    return False
        return True
        
    def _ullmann_search(self, row, M, result):
        if row == self.n1:
            # Нашли изоморфизм
            mapping = []
            for i in range(self.n1):
                for j in range(self.n2):
                    if M[i][j] == 1:
                        mapping.append(j)
                        break
            result.append(mapping)
            return
            
        # Перебираем возможные отображения для текущей строки
        for j in range(self.n2):
            if M[row][j] == 1:
                # Сохраняем текущее состояние
                old_M = [row[:] for row in M]
                
                # Обновляем матрицу M
                for k in range(self.n1):
                    for l in range(self.n2):
                        if k == row or l == j:
                            M[k][l] = 0
                M[row][j] = 1
                
                # Рекурсивный поиск
                self._ullmann_search(row + 1, M, result)
                
                # Восстанавливаем состояние
                M = old_M
```

## Применение изоморфизма

### Химическая информатика

**Теорема**: Задача поиска молекулярных структур сводится к задаче изоморфизма графов.

**Доказательство**:
1. Молекула представляется как граф
2. Атомы - вершины, связи - рёбра
3. Поиск структуры - поиск изоморфного подграфа

Применения:
- Поиск молекулярных структур
- Анализ химических соединений
- Прогнозирование свойств веществ

### Биоинформатика

**Теорема**: Задача сравнения белковых структур сводится к задаче изоморфизма графов с весами.

**Доказательство**:
1. Белок представляется как граф
2. Аминокислоты - вершины, взаимодействия - рёбра
3. Веса рёбер отражают силу взаимодействий

Применения:
- Сравнение белковых структур
- Анализ метаболических путей
- Исследование генетических сетей

### Компьютерное зрение

**Теорема**: Задача распознавания объектов сводится к задаче изоморфизма графов с атрибутами.

**Доказательство**:
1. Объект представляется как граф
2. Ключевые точки - вершины, связи - рёбра
3. Атрибуты вершин и рёбер описывают особенности

Применения:
- Распознавание объектов
- Сопоставление изображений
- Анализ сцен

### Сетевой анализ

**Теорема**: Задача поиска похожих сетей сводится к задаче изоморфизма графов с метрикой.

**Доказательство**:
1. Сеть представляется как граф
2. Узлы - вершины, соединения - рёбра
3. Метрика определяет схожесть структур

Применения:
- Поиск похожих сетей
- Анализ социальных графов
- Обнаружение аномалий

## Сложность алгоритмов

### Точный изоморфизм
- Время: O(n!)
- Память: O(n²)

### Поиск подграфа
- Время: O(n! * C(n,m))
- Память: O(n²)

### Алгоритм Ульмана
- Время: O(n! * n²)
- Память: O(n²)

где:
- n - число вершин в меньшем графе
- m - число вершин в большем графе
- C(n,m) - число сочетаний из m по n 